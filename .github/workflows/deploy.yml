name: Production CI/CD Pipeline

on:
  push:
    branches: [main]

env:
  PORT: 6800
  APP_ENV: production
  NODE_ENV: production
  APP_NAME: meet-live-api
  SERVER_USER: ${{ secrets.SERVER_USER }}
  SERVER_HOST: ${{ secrets.SERVER_HOST }}
  SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
  DOCKER_USER: ${{ secrets.DOCKER_USER }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  DB_HOST: ${{ secrets.DB_HOST }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  DB_DATABASE: ${{ secrets.DB_DATABASE }}
  GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
  GOOGLE_SECRET: ${{ secrets.GOOGLE_SECRET }}
  GOOGLE_REDIRECT_URL: ${{ secrets.GOOGLE_REDIRECT_URL }}

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate .env
        run: |
          envsubst "`printf '${%s} ' $(sh -c "env|cut -d'=' -f1")`" < ./environments/prod.example.env > ./environments/$NODE_ENV.env
          echo "Generated environment file:"
          cat ./environments/$NODE_ENV.env
        env:
          PORT: ${{ env.PORT }}
          APP_ENV: ${{ env.APP_ENV }}
          NODE_ENV: ${{ env.APP_ENV }}
          API_PREFIX: api/v1
          TZ: UTC

          # Swagger
          API_VERSION: 1.0.0
          API_TITLE: "r-tech meet app"
          API_DESCRIPTION: "r-tech meet app"

          # Default DB
          DB_TYPE: postgres
          DB_HOST: ${{ env.DB_HOST }}
          DB_PORT: 5432
          DB_USERNAME: ${{ env.DB_USERNAME }}
          DB_PASSWORD: ${{ env.DB_PASSWORD }}
          DB_DATABASE: ${{ env.DB_DATABASE }}
          DB_SYNCHRONIZE: true
          DB_LOGGING: false
          DB_SSLMODE: false
          DB_REJECT_UNAUTHORIZED: false

          # Security
          CORS_ALLOWED_ORIGINS: http://localhost, http://localhost:5800, https://meet-api.r-tech.live, https://meet.r-tech.live
          RATE_LIMIT_TTL: 60000
          RATE_LIMIT_MAX: 100

          # Logger
          LOG_FOLDER: logs

          # JWT
          JWT_SECRET: db222766fa5cd7d6df05b7f29072bcc311d4575a1a589e24d7f6e03e84484931d7a068f651d17011974dd680fd4af767d0ce
          JWT_SALT_ROUNDS: 10
          JWT_EXPIRES_IN: 30d
          JWT_REFRESH_TOKEN_EXPIRES_IN: 30d

          # S3
          S3_ENDPOINT: sgp1.digitaloceanspaces.com
          S3_REGION: sgp1
          S3_ACCESS_KEY: DO00J7N6BMX64HRNTKUN
          S3_SECRET_KEY: Rqf25w+w9On9DLeIS5LIPa18kEWmEoXjKDHs5MOtW2Q
          S3_BUCKET: unispaces
          S3_FOLDER_PREFIX: nebula

          # Redis
          REDIS_HOST: 157.245.50.140
          REDIS_PORT: 6379
          REDIS_USERNAME: default
          REDIS_PASSWORD: 30kLkJSDjXp2
          REDIS_TLS: false

          # SMTP
          SMTP_HOST:
          SMTP_PORT:
          SMTP_SECURE:
          SMTP_AUTH_USER:
          SMTP_AUTH_PASS:

          # Google Auth
          GOOGLE_CLIENT_ID: ${{ env.GOOGLE_CLIENT_ID }}
          GOOGLE_SECRET: ${{ env.GOOGLE_SECRET }}
          GOOGLE_REDIRECT_URL: ${{ env.GOOGLE_REDIRECT_URL }}

          # Seed Database
          SUPER_ADMIN_EMAIL: galib@gmail.com
          SUPER_ADMIN_PASSWORD: 123456

          LIVEKIT_API_KEY: galib
          LIVEKIT_API_SECRET: 123456galib
          LIVEKIT_SERVER_URL: wss://r-tech.live

      - name: Login to Docker Hub
        run: echo "${{ env.DOCKER_PASSWORD }}" | docker login -u "${{ env.DOCKER_USER }}" --password-stdin

      - name: Build Docker image
        run: |
          docker build . --file Dockerfile --tag ${{ env.DOCKER_USER }}/${{ env.APP_NAME }}:latest
          docker tag ${{ env.DOCKER_USER }}/${{ env.APP_NAME }}:latest ${{ env.DOCKER_USER }}/${{ env.APP_NAME }}:${{ github.sha }}

      - name: Push Docker image
        run: |
          docker push ${{ env.DOCKER_USER }}/${{ env.APP_NAME }}:latest
          docker push ${{ env.DOCKER_USER }}/${{ env.APP_NAME }}:${{ github.sha }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Deploy to Server with Zero Downtime
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          password: ${{ env.SERVER_PASSWORD }}
          timeout: 300s
          command_timeout: 300s
          script: |
            set -e

            # Enable error handling and logging
            exec > >(tee -a /var/log/deploy.log) 2>&1
            echo "=== Deployment started at $(date) ==="

            # Login to Docker Hub
            echo "Logging into Docker Hub..."
            echo "${{ env.DOCKER_PASSWORD }}" | docker login -u "${{ env.DOCKER_USER }}" --password-stdin

            # Pull latest image
            echo "Pulling latest Docker image..."
            docker pull ${{ env.DOCKER_USER }}/${{ env.APP_NAME }}:latest

            # Clean up any dangling images
            docker image prune -f || true

            # Detect current running container and port
            echo "Detecting current deployment..."
            CURRENT_PORT=""
            OLD_CONTAINER=""

            # Check if nginx config exists and get current port
            if [ -f "/etc/nginx/sites-enabled/meet-api.r-tech.live" ]; then
              CURRENT_PORT=$(grep -oP '(?<=proxy_pass http://127.0.0.1:)\d+' /etc/nginx/sites-enabled/meet-api.r-tech.live 2>/dev/null || echo "")
            fi

            # Determine new port and container names
            if [ -z "$CURRENT_PORT" ] || [ "$CURRENT_PORT" == "6800" ]; then
              NEW_PORT=6801
              NEW_CONTAINER=meet-live-api-6801
              if [ "$CURRENT_PORT" == "6800" ]; then
                OLD_CONTAINER=meet-live-api-6800
              fi
            else
              NEW_PORT=6800
              NEW_CONTAINER=meet-live-api-6800
              OLD_CONTAINER=meet-live-api-6801
            fi

            echo "Current port: ${CURRENT_PORT:-none}"
            echo "New port: $NEW_PORT"
            echo "New container: $NEW_CONTAINER"
            echo "Old container: ${OLD_CONTAINER:-none}"

            # Stop and remove new container if it exists
            if docker ps -a --format 'table {{.Names}}' | grep -q "^$NEW_CONTAINER$"; then
              echo "Removing existing container: $NEW_CONTAINER"
              docker rm -f $NEW_CONTAINER || true
            fi

            # Create uploads directory if it doesn't exist
            mkdir -p /var/www/uploads

            # Start new container
            echo "Starting new container: $NEW_CONTAINER on port $NEW_PORT"
            docker run -d --name $NEW_CONTAINER \
              -e NODE_ENV=production \
              --restart always \
              -p $NEW_PORT:6800 \
              -v /var/www/uploads:/uploads \
              ${{ env.DOCKER_USER }}/${{ env.APP_NAME }}:latest

            # Wait for container to be ready
            echo "Waiting for container to start..."
            sleep 10

            # Health check with better error handling
            echo "Performing health check on port $NEW_PORT..."
            HEALTH_CHECK_PASSED=false

            for i in {1..30}; do
              echo "Health check attempt $i/30..."
              
              # Check if container is still running
              if ! docker ps --format 'table {{.Names}}' | grep -q "^$NEW_CONTAINER$"; then
                echo "❌ Container $NEW_CONTAINER is not running!"
                docker logs $NEW_CONTAINER 2>&1 | tail -50
                exit 1
              fi
              
              # Check health endpoint
              if curl -sSf --connect-timeout 5 --max-time 10 http://localhost:$NEW_PORT/api/v1/health > /dev/null 2>&1; then
                echo "✅ Health check passed on port $NEW_PORT"
                HEALTH_CHECK_PASSED=true
                break
              fi
              
              if [ $i -eq 30 ]; then
                echo "❌ Health check failed after 30 attempts"
                echo "Container logs:"
                docker logs $NEW_CONTAINER 2>&1 | tail -50
                exit 1
              fi
              
              sleep 5
            done

            # Update Nginx configuration
            if [ "$HEALTH_CHECK_PASSED" = true ]; then
              echo "Updating Nginx configuration..."
              
              # Create nginx config if it doesn't exist
              if [ ! -f "/etc/nginx/sites-enabled/meet-api.r-tech.live" ]; then
                echo "Creating new Nginx configuration..."
                cat > /etc/nginx/sites-enabled/meet-api.r-tech.live << EOF
            server {
                listen 80;
                server_name meet-api.r-tech.live;
                
                location / {
                    proxy_pass http://127.0.0.1:$NEW_PORT;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_cache_bypass \$http_upgrade;
                }
            }
            EOF
              else
                # Update existing configuration
                if [ -n "$CURRENT_PORT" ]; then
                  sed -i "s/proxy_pass http:\/\/127.0.0.1:$CURRENT_PORT;/proxy_pass http:\/\/127.0.0.1:$NEW_PORT;/" /etc/nginx/sites-enabled/meet-api.r-tech.live
                else
                  sed -i "s/proxy_pass http:\/\/127.0.0.1:[0-9]*;/proxy_pass http:\/\/127.0.0.1:$NEW_PORT;/" /etc/nginx/sites-enabled/meet-api.r-tech.live
                fi
              fi

              # Test nginx configuration
              if nginx -t; then
                echo "Reloading Nginx..."
                nginx -s reload
                echo "✅ Nginx reloaded successfully"
              else
                echo "❌ Nginx configuration test failed"
                exit 1
              fi

              # Clean up old container after successful deployment
              if [ -n "$OLD_CONTAINER" ]; then
                echo "Cleaning up old container: $OLD_CONTAINER"
                docker rm -f $OLD_CONTAINER || true
              fi

              # Clean up old images (keep last 3)
              echo "Cleaning up old Docker images..."
              docker images ${{ env.DOCKER_USER }}/${{ env.APP_NAME }} --format "table {{.Tag}}\t{{.ID}}" | grep -v "latest" | tail -n +4 | awk '{print $2}' | xargs -r docker rmi || true

              echo "✅ Deployment completed successfully at $(date)"
              echo "✅ Application is running on port $NEW_PORT"
            fi
